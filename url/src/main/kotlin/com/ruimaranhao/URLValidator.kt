package com.ruimaranhao

import org.apache.log4j.Logger
import java.io.*
import java.net.DatagramPacket
import java.net.DatagramSocket
import java.net.InetAddress

class URLValidator {


    companion object {

        private val log = Logger.getLogger(URLValidtor::class.java)

        private val DNS_SERVER_ADDRESS = "8.8.8.8"
        private val DNS_SERVER_PORT = 53

        @Throws(IOException::class)
        fun isURL(url: String): Boolean {
            val ipAddress = InetAddress.getByName(DNS_SERVER_ADDRESS)

            val baos = ByteArrayOutputStream()
            val dos = DataOutputStream(baos)


            // Identifier: A 16-bit identification field generated by the device that creates the DNS query.
            // It is copied by the server into the response, so it can be used by that device to match that
            // query to the corresponding reply received from a DNS server. This is used in a manner similar
            // to how the Identifier field is used in many of the ICMP message types.
            dos.writeShort(0x1234)

            // Write Query Flags
            dos.writeShort(0x0100)

            // Question Count: Specifies the number of questions in the Question section of the message.
            dos.writeShort(0x0001)

            // Answer Record Count: Specifies the number of resource records in the Answer section of the message.
            dos.writeShort(0x0000)

            // Authority Record Count: Specifies the number of resource records in the Authority section of
            // the message. (“NS” stands for “name server”)
            dos.writeShort(0x0000)

            // Additional Record Count: Specifies the number of resource records in the Additional section of the message.
            dos.writeShort(0x0000)

            val domainParts = url.split("\\.".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
            log.debug(url + " has " + domainParts.size + " parts")

            for (i in domainParts.indices) {
                log.debug("Writing: " + domainParts[i])
                val domainBytes = domainParts[i].toByteArray(charset("UTF-8"))
                dos.writeByte(domainBytes.size)
                dos.write(domainBytes)
            }

            // No more parts
            dos.writeByte(0x00)

            // Type 0x01 = A (Host Request)
            dos.writeShort(0x0001)

            // Class 0x01 = IN
            dos.writeShort(0x0001)

            val dnsFrame = baos.toByteArray()

            println("Sending: " + dnsFrame.size + " bytes")
            for (i in dnsFrame.indices) {
                log.debug("0x" + String.format("%x", dnsFrame[i]) + " ")
            }

            // *** Send DNS Request Frame ***
            val socket = DatagramSocket()
            val dnsReqPacket = DatagramPacket(dnsFrame, dnsFrame.size, ipAddress, DNS_SERVER_PORT)
            socket.send(dnsReqPacket)

            // Await response from DNS server
            val buf = ByteArray(1024)
            val packet = DatagramPacket(buf, buf.size)
            socket.receive(packet)

            log.debug("\n\nReceived: " + packet.length + " bytes")

            for (i in 0..packet.length - 1) {
                log.debug(" 0x" + String.format("%x", buf[i]) + " ")
            }
            log.debug("\n")


            val din = DataInputStream(ByteArrayInputStream(buf))
            log.debug("Tx ID: 0x" + String.format("%x", din.readShort()))
            log.debug("Flags: 0x" + String.format("%x", din.readShort()))
            log.debug("Questions: 0x" + String.format("%x", din.readShort()))
            log.debug("Answers RRs: 0x" + String.format("%x", din.readShort()))
            log.debug("Authority RRs: 0x" + String.format("%x", din.readShort()))
            log.debug("Additional RRs: 0x" + String.format("%x", din.readShort()))


            var recLen = din.readByte().toInt()
            while (recLen > 0) {
                val record = ByteArray(recLen)

                for (i in 0..recLen - 1) {
                    record[i] = din.readByte()
                }

                log.debug("Record: " + String(record))

                recLen = din.readByte().toInt()
            }

            log.debug("Record Type: 0x" + String.format("%x", din.readShort()))
            log.debug("Class: 0x" + String.format("%x", din.readShort()))

            log.debug("Field: 0x" + String.format("%x", din.readShort()))
            log.debug("Type: 0x" + String.format("%x", din.readShort()))
            log.debug("Class: 0x" + String.format("%x", din.readShort()))
            log.debug("TTL: 0x" + String.format("%x", din.readInt()))

            val addrLen = din.readShort()
            log.debug("Len: 0x" + String.format("%x", addrLen))

            if (addrLen.toInt() != 4) { //if address >4, then there is not IP address for the url. Garbage returned only.
                log.info("Not an URL!")

                return false

            } else {
                log.info("Valid URL!")

                log.debug("Address: ")
                for (i in 0..addrLen - 1) {
                    log.debug("" + String.format("%d", din.readByte().toInt() and 0xFF) + ".")
                }


                return true
            }
        }
    }

}